#labels Phase-Deploy
<wiki:toc max_depth="2" />

== Getting sources ==

You need checkout source code from the trunk of the project repository, please find links at [http://code.google.com/p/cpptask/source/checkout Source] page.

== Compilation remarks ==

On Windows platform library usually can be simply included to the project. But on Posix platforms you have to add "pthread" library to your linker, for gcc it can be done by adding "-pthread" command line parameter.

== Building examples ==

Root directory of the project contain sub directory named "examples" where you can find [http://industriousone.com/premake Premake] executable. You can make build scripts for system you like. For example if you need solution for VS2010 you need type in console "premake4 vs2010", after that you will get directory named "build_scripts" where VS projects and solution will be placed.

== Thread class ==

If you need only simple thread implementation, you could use {{{cpptask::Thread}}} class, where you will need override Run method of the class. Or you can use {{{cpptask::ThreadFunction}}} class, which take functor as constructor parameter.
{{{
#include <thread.h>
...
typedef void (*ThreadFunc)(void);
void ThreadFunc1()
{
   //do work
}
...
spptask::ThreadFunction<ThreadFunc> mythread(&ThreadFunc1);
mythread.Start();
...
mythread.Wait();
...
}}}
== Atomic variables ==

Library provide only two types of atomics values:
 * {{{cpptask::AtomicFlag}}} - class represents boolean values you can Set flag and Reset it.
{{{
#include <atomic.h>
...
cpptask::AtomicFlag someFlag;
someFlag.Set();
if (someFlag.IsSet())
{
    ...
    someFlag.Reset();
}
...
}}}
 * {{{cpptask::AtomicNumber}}} - class represents c++ long value type you can atomicaly {{{Inc/Dec}}} and {{{SetValue/GetValue}}} from it.
{{{
#include <atomic.h>
...
cpptask::AtomicNumber counter;
counter.SetValue(10);
...
counter.Inc();
...
counter.Dec();
...
if (counter.GetValue() == 10)
{
    ...
}
...
}}}

== Mutex primitive ==

Standard Mutex synchronization primitive:
{{{
#include <mutex.h>
...
cpptask::Mutex guard;
...
{
   cpptask::ScopedLock(&guard);
   // synchronized work
   ...
}
...
long timeInMiliseconds = 10;
if (quard.WaitLock(timeInMiliseconds))
{
   // wait for given time when mutex will be released and make a lock
   ...
   quard.UnLock();
}
...
}}}

== Event primitive ==

== Task class for faster job delivering to threads ==

== Parallel-For algorithm ==

== Parallel-Reduce algorithm ==

== Parallel-Invoke algorithm ==

== Delivering exceptions from threads and tasks to caller ==

== Support of lambda expressions  ==
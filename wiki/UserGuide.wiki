#labels Phase-Deploy
<wiki:toc max_depth="2" />

== Getting sources ==

You need checkout source code from the trunk of the project repository, please find links at [http://code.google.com/p/cpptask/source/checkout Source] page.

== Compilation remarks ==

On Windows platform library usually can be simply included to the project. But on Posix platforms you have to add "pthread" library to your linker, for gcc it can be done by adding "-pthread" command line parameter.

== Building examples ==

Root directory of the project contain sub directory named "examples" where you can find [http://industriousone.com/premake Premake] executable. You can make build scripts for system you like. For example if you need solution for VS2010 you need type in console "premake4 vs2010", after that you will get directory named "build_scripts" where VS projects and solution will be placed.

== Thread class ==

If you need only simple thread implementation, you could use {{{cpptask::Thread}}} class, where you will need override Run method of the class. Or you can use {{{cpptask::ThreadFunction}}} class, which take functor as constructor parameter.
{{{
#include <thread.h>
...
typedef void (*ThreadFunc)(void);
void ThreadFunc1()
{
   //do work
}
...
spptask::ThreadFunction<ThreadFunc> mythread(&ThreadFunc1);
mythread.Start();
...
mythread.Wait();
...
}}}
== Atomic variables ==

Library provide only two types of atomics values:
 * {{{cpptask::AtomicFlag}}} - class represents boolean values you can Set flag and Reset it.
{{{
#include <atomic.h>
...
cpptask::AtomicFlag someFlag;
someFlag.Set();
if (someFlag.IsSet())
{
    ...
    someFlag.Reset();
}
...
}}}
 * {{{cpptask::AtomicNumber}}} - class represents c++ long value type you can atomicaly {{{Inc/Dec}}} and {{{SetValue/GetValue}}} from it.
{{{
#include <atomic.h>
...
cpptask::AtomicNumber counter;
counter.SetValue(10);
...
counter.Inc();
...
counter.Dec();
...
if (counter.GetValue() == 10)
{
    ...
}
...
}}}

== Mutex primitive ==

Standard Mutex synchronization primitive:
{{{
#include <mutex.h>
...
cpptask::Mutex guard;
...
{
   cpptask::ScopedLock(&guard);
   // synchronized work
   ...
}
...
long timeInMiliseconds = 10;
if (quard.WaitLock(timeInMiliseconds))
{
   // wait for given time when mutex will be released and make a lock
   ...
   quard.UnLock();
}
...
}}}

== Event primitive ==

Windows API like Event synchronization primitive. One thread can wait for an event which can be signaled from many other threads.
{{{
#include <event.h>
...
cpptask::Event event;
...
event.Signal();
...
event.Wait();
// do work work
event.Reset();
...
std::vector<Events*> events;
int signaled = WaitForMultiple(events);
switch (signaled)
{
case -1: 
    // error
    break;
case 0:
    // first event is in signaled state
    break;
case 1:
    // second event is in signaled state
    break;
}
}}}

== Task class for faster job delivering to threads ==
To schedule some job to the thread engine you can derive your class from the Task class and override Execute method. Then you have to create and initialize {{{TaskManager}}} object. After that you have to add task to the manager and ask manager to start new jobs. Also Task class have method Wait which will lock you thread until task will be processed, and have method {{{GetLastException}}} which you can call after wait to check if there were some exceptions.
{{{
#include "task.h"
...
class MyTask : public Task
{
public:
    virtual void Execute()
    {
        ...
    }
};
...
#include "taskmanager.h"
...
cpptask::TaskThreadPool threadPool(THREADS_NUM);
cpptask::TaskManager manager(threadPool);
std::shared_ptr<MyTask> task(new MyTask);
manager.AddTask(task.get());
manager.StartTasks();
...
task->Wait();
}}}

== Parallel-For algorithm ==
Algorithm to execute in parallel some identical operations on container's elements.
{{{
#include <parallelfor.h>
...
cpptask::TaskThreadPool threadPool(THREADS_NUM);
cpptask::TaskManager manager(threadPool);
...
void func()(double& x)
{
   //some operation
}
...
std::vector<double> array;
...
cpptask::ParallelFor(array.begin(), array.end(), func, manager);
}}}

== Parallel-Reduce algorithm ==

== Parallel-Invoke algorithm ==

== Delivering exceptions from threads and tasks to caller ==